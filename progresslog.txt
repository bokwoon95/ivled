✓ Unmarshal a simple json structure from a file

✓ Unmarshal an array of simple json structures from a file

✓ Unmarshal an array of json structures (that can be one of two types) from a file
    ✓ Kind of achieved with a union struct, a very ugly solution

✗ Why is Unmarshal() blatantly ignoring certain elements in my Results[] json array?
    • What I will try next is
    "Cool trick: you can parse the same JSON using multiple structs, to adjust to different contents dynamically this way."
    Instead of reading it into a recursive homofolder struct, I can recursively parse the json. Arrays of unknown contents will simply be parsed as '[]json.RawMessage', which I can iterate over at my own leisure(https://stackoverflow.com/a/52250578).
        • I was having problems trying to get json.RawMessage to be recognized (apparently jsoniter has no API for json.RawMessage) so I switched over to "encoding/json" to try it out
    • What the fuck? If I switch back to the "encoding/json" stdlib the homofolders suddenly become correctly parsed. Could it be because of a regression in the supposedly 'drop-in replacement' jsoniter library?

Resources
=========
• Dealing With JSON With Non-Homogeneous Types In GO
https://engineering.bitnami.com/articles/dealing-with-json-with-non-homogeneous-types-in-go.html

• Decode top level JSON array into a slice of structs in golang
https://coderwall.com/p/4c2zig/decode-top-level-json-array-into-a-slice-of-structs-in-golang

• simplejson
https://godoc.org/github.com/bitly/go-simplejson

lapi.sh
=======

✓ A function that generates a json array of this semester's modules together with the module ID (and cache it into a 'modules_taken.json' file). With the unique ID of each module, I can
✗ Write all temporary json files into a /tmp folder and clean up after you're done
    Writing to a /tmp folder also helps to avoid deleting other people's json files that match 'temp*.json'

✗ How the eff do I travel the json tree? Traversal can probaby be done in jq, but I'll miss out on bash's file handing. Bash has commands for file handling, but it needs jq to traverse the tree.

✗ If a FolderName has 'Submissions' (as in 'Student Submissions') in it, do not download anything from the folder.

✗ Unacceptable filetypes: video, audio, anything above 5MB

Possible Failures
=================
✗ The module searching by regex might throw up either no results, or more than one result. Right now I'm assuming it will always return only one result. This assumption needs to be tested with a wide range of other people's modules.
    Possibly implement a failsafe that throws an error when no results are found, and (intelligently) selects one result if there are multiple results found.

Pseudocode
==========
Title & Folders[] --> workbin (Title, Folders[])
FolderName --> folder (FolderName, Folders[], Files[])
FileName --> file (FileName, FileType, FileSize, ID)

walk($1=relpath, $2=jsonblob) {
    if $2.Title and $2.Folders[]
        for f in Folders[]
            walk "$1""/Title" "$f"
        end
    elif $2.FolderName
        for f in Folders[]
            walk "$1""/FolderName" "$f"
        end
        for f in Files[]
            walk "$1""/FolderName" "$f"
        end
    elif $2.FileName
    else
    end
}
